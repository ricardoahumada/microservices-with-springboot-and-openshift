# Arquitectura Hexagonal

## ¿Qué es la Arquitectura Hexagonal?

La Arquitectura Hexagonal, también conocida como **Ports and Adapters** o **Arquitectura de Puertos y Adaptadores**, es un patrón de diseño de software que busca crear aplicaciones débilmente acopladas y altamente testeables.

### Conceptos Fundamentales

La arquitectura hexagonal divide la aplicación en tres capas principales:

#### 1. **Dominio (Core) - Centro del Hexágono**
- Contiene la lógica de negocio pura
- Independiente de frameworks, bases de datos o servicios externos
- Define interfaces (puertos) para interactuar con el exterior
- Es el corazón de la aplicación

#### 2. **Aplicación - Segundo Anillo**
- Orquesta los casos de uso
- Implementa la lógica de aplicación
- Utiliza los puertos definidos por el dominio
- Controla el flujo de datos

#### 3. **Infraestructura - Anillo Externo**
- Implementa los adaptadores externos
- Se comunica con bases de datos, APIs, servicios web
- Adapta las interfaces externas a los puertos internos
- Plugins intercambiables

### Puertos y Adaptadores

#### **Puertos (Ports)**
- Interfaces Java que definen contratos
- Especifican qué operaciones puede realizar la aplicación
- No dependen de implementaciones específicas

#### **Adaptadores (Adapters)**
- Implementaciones concretas de los puertos
- Conectan la aplicación con sistemas externos
- Pueden intercambiarse sin afectar el core

## Casos de Uso

### 1. **Aplicaciones Empresariales**
- Sistemas que requieren múltiples interfaces (web, mobile, API)
- Aplicaciones que deben integrarse con diversos sistemas externos
- Proyectos con alta variabilidad en requisitos tecnológicos

### 2. **Microservicios**
- Servicios independientes que necesitan comunicación flexible
- APIs que deben soportar múltiples protocolos
- Sistemas distribuidos con diferentes tipos de clientes

### 3. **Aplicaciones con Lógica Compleja**
- Sistemas donde la lógica de negocio es crítica
- Aplicaciones que requieren alta testabilidad
- Proyectos que evolucionan constantemente

### 4. **Sistemas Legado Modernizados**
- Aplicaciones existentes que necesitan desacoplarse
- Integración gradual con nuevas tecnologías
- Migración hacia arquitecturas más flexibles

## Ejemplos en Java

### Ejemplo 1: Sistema de Gestión de Usuarios

#### Puerto (Interfaz)
```java
// Puerto - Define el contrato
public interface UserRepository {
    User findById(Long id);
    User save(User user);
    void delete(Long id);
    List<User> findAll();
}

// Puerto para notificaciones
public interface NotificationPort {
    void sendWelcomeEmail(User user);
    void sendPasswordReset(User user);
}
```

#### Dominio (Entidad y Servicio)
```java
// Entidad del dominio
public class User {
    private Long id;
    private String email;
    private String password;
    private String name;
    
    public User(String email, String password, String name) {
        validateEmail(email);
        validatePassword(password);
        this.email = email;
        this.password = password;
        this.name = name;
    }
    
    public void changePassword(String newPassword) {
        validatePassword(newPassword);
        this.password = newPassword;
    }
    
    private void validateEmail(String email) {
        if (!email.contains("@")) {
            throw new IllegalArgumentException("Email inválido");
        }
    }
    
    private void validatePassword(String password) {
        if (password.length() < 8) {
            throw new IllegalArgumentException("Contraseña muy corta");
        }
    }
}

// Servicio del dominio
public class UserService {
    private final UserRepository userRepository;
    private final NotificationPort notificationPort;
    
    public UserService(UserRepository userRepository, NotificationPort notificationPort) {
        this.userRepository = userRepository;
        this.notificationPort = notificationPort;
    }
    
    public User registerNewUser(String email, String password, String name) {
        User newUser = new User(email, password, name);
        User savedUser = userRepository.save(newUser);
        notificationPort.sendWelcomeEmail(savedUser);
        return savedUser;
    }
    
    public void resetPassword(Long userId) {
        User user = userRepository.findById(userId);
        String newPassword = generateTemporaryPassword();
        user.changePassword(newPassword);
        userRepository.save(user);
        notificationPort.sendPasswordReset(user);
    }
    
    private String generateTemporaryPassword() {
        return "temp_" + System.currentTimeMillis();
    }
}
```

#### Adaptadores (Implementaciones)

```java
// Adaptador para JPA
@Repository
public class JpaUserRepository implements UserRepository {
    
    @Autowired
    private UserEntityRepository entityRepository;
    
    @Override
    public User findById(Long id) {
        UserEntity entity = entityRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException("Usuario no encontrado"));
        return mapToDomain(entity);
    }
    
    @Override
    public User save(User user) {
        UserEntity entity = mapToEntity(user);
        UserEntity saved = entityRepository.save(entity);
        return mapToDomain(saved);
    }
    
    @Override
    public void delete(Long id) {
        entityRepository.deleteById(id);
    }
    
    @Override
    public List<User> findAll() {
        return entityRepository.findAll().stream()
            .map(this::mapToDomain)
            .collect(Collectors.toList());
    }
    
    private User mapToDomain(UserEntity entity) {
        return new User(entity.getEmail(), entity.getPassword(), entity.getName());
    }
    
    private UserEntity mapToEntity(User user) {
        UserEntity entity = new UserEntity();
        entity.setEmail(user.getEmail());
        entity.setPassword(user.getPassword());
        entity.setName(user.getName());
        return entity;
    }
}

// Adaptador para notificaciones por email
@Component
public class EmailNotificationAdapter implements NotificationPort {
    
    @Autowired
    private EmailService emailService;
    
    @Override
    public void sendWelcomeEmail(User user) {
        String subject = "¡Bienvenido a nuestra plataforma!";
        String body = String.format("Hola %s, bienvenido a nuestra plataforma.", user.getName());
        emailService.sendEmail(user.getEmail(), subject, body);
    }
    
    @Override
    public void sendPasswordReset(User user) {
        String subject = "Restablecimiento de contraseña";
        String body = "Se ha restablecido tu contraseña. Por favor, inicia sesión.";
        emailService.sendEmail(user.getEmail(), subject, body);
    }
}
```

#### Controlador (Adapter Web)
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @PostMapping
    public ResponseEntity<UserDTO> registerUser(@RequestBody UserRegistrationRequest request) {
        User user = userService.registerNewUser(
            request.getEmail(), 
            request.getPassword(), 
            request.getName()
        );
        return ResponseEntity.ok(mapToDTO(user));
    }
    
    @PostMapping("/{id}/reset-password")
    public ResponseEntity<Void> resetPassword(@PathVariable Long id) {
        userService.resetPassword(id);
        return ResponseEntity.ok().build();
    }
    
    private UserDTO mapToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setEmail(user.getEmail());
        dto.setName(user.getName());
        return dto;
    }
}
```

### Ejemplo 2: Sistema de Pagos

```java
// Puerto para procesamiento de pagos
public interface PaymentProcessorPort {
    PaymentResult processPayment(PaymentRequest request);
    RefundResult refundPayment(String transactionId);
}

// Puerto para notificaciones de pago
public interface PaymentNotificationPort {
    void notifyPaymentSuccess(Payment payment);
    void notifyPaymentFailure(Payment payment, String reason);
}

// Servicio de aplicación
public class PaymentService {
    private final PaymentProcessorPort paymentProcessor;
    private final PaymentNotificationPort notificationPort;
    private final PaymentRepository paymentRepository;
    
    public PaymentService(PaymentProcessorPort paymentProcessor,
                         PaymentNotificationPort notificationPort,
                         PaymentRepository paymentRepository) {
        this.paymentProcessor = paymentProcessor;
        this.notificationPort = notificationPort;
        this.paymentRepository = paymentRepository;
    }
    
    public PaymentResult executePayment(PaymentRequest request) {
        Payment payment = new Payment(request.getAmount(), request.getCurrency());
        PaymentResult result = paymentProcessor.processPayment(request);
        
        payment.setStatus(result.isSuccess() ? PaymentStatus.SUCCESS : PaymentStatus.FAILED);
        payment.setTransactionId(result.getTransactionId());
        paymentRepository.save(payment);
        
        if (result.isSuccess()) {
            notificationPort.notifyPaymentSuccess(payment);
        } else {
            notificationPort.notifyPaymentFailure(payment, result.getErrorMessage());
        }
        
        return result;
    }
}
```

## Ventajas (Pros)

### 1. **Bajo Acoplamiento**
- El dominio es independiente de frameworks
- Cambios en infraestructura no afectan la lógica de negocio
- Facilita el mantenimiento a largo plazo

### 2. **Alta Testabilidad**
- Fácil creación de tests unitarios
- Mocks y stubs simples de implementar
- Tests que no dependen de infraestructura externa

### 3. **Flexibilidad Tecnológica**
- Cambio de base de datos sin afectar el dominio
- Soporte para múltiples interfaces de usuario
- Integración sencilla con servicios externos

### 4. **Separación de Responsabilidades**
- Lógica de negocio claramente separada
- Código más organizado y mantenible
- Facilita el trabajo en equipo

### 5. **Reutilización**
- Puertos reutilizables en diferentes contextos
- Adaptadores intercambiables
- Lógica de negocio reutilizable

## Desventajas (Contras)

### 1. **Complejidad Inicial**
- Curva de aprendizaje pronunciada
- Más clases e interfaces para crear
- Configuración inicial más compleja

### 2. **Sobreingeniería**
- Puede ser excesiva para proyectos pequeños
- Demasiada abstracción para aplicaciones simples
- Incremento en el tiempo de desarrollo inicial

### 3. **Performance**
- Capas adicionales pueden impactar rendimiento
- Múltiples invocaciones de métodos
- Overhead en aplicaciones críticas de performance

### 4. **Complejidad de Depuración**
- Múltiples capas dificultan el debugging
- Trazabilidad más compleja
- Stack traces más largos

### 5. **Curva de Aprendizaje**
- Requiere comprensión profunda de patrones
- Necesita experiencia en arquitectura de software
- Puede ser intimidante para desarrolladores junior

## Buenas Prácticas

### 1. **Diseño de Puertos**
```java
// ✅ Buen puerto - específico y claro
public interface EmailSenderPort {
    void sendEmail(String to, String subject, String body);
}

// ❌ Mal puerto - muy genérico
public interface ServicePort {
    Object execute(Object request);
}
```

### 2. **Nomenclatura Consistente**
```java
// ✅ Uso claro de nomenclatura
public interface UserRepositoryPort { ... }
public class JpaUserRepositoryAdapter implements UserRepositoryPort { ... }

// ❌ Nomenclatura confusa
public interface UserRepo { ... }
public class UserDAO implements UserRepo { ... }
```

### 3. **Validación en el Dominio**
```java
public class Order {
    private final Money total;
    
    public Order(List<OrderItem> items) {
        if (items.isEmpty()) {
            throw new IllegalArgumentException("La orden no puede estar vacía");
        }
        this.total = calculateTotal(items);
        validateOrder();
    }
    
    private void validateOrder() {
        if (total.isLessThan(Money.of(10))) {
            throw new IllegalArgumentException("Orden mínima de $10");
        }
    }
}
```

### 4. **Mapeo Limpio entre Capas**
```java
// Mapper para conversión entre capas
@Component
public class UserDTOMapper {
    
    public UserDTO toDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setEmail(user.getEmail());
        dto.setName(user.getName());
        return dto;
    }
    
    public User toDomain(UserRegistrationRequest request) {
        return new User(request.getEmail(), request.getPassword(), request.getName());
    }
}
```

### 5. **Configuración por Inyección de Dependencias**
```java
@Configuration
public class HexagonalConfiguration {
    
    @Bean
    public UserService userService(UserRepositoryPort userRepository,
                                  NotificationPort notificationPort) {
        return new UserService(userRepository, notificationPort);
    }
    
    @Bean
    public UserRepositoryPort userRepository() {
        return new JpaUserRepositoryAdapter(); // O cualquier implementación
    }
}
```

### 6. **Tests Independientes de Infraestructura**
```java
// Test del dominio sin dependencias externas
@Test
public void shouldCreateUserWithValidData() {
    // Given
    UserRepositoryPort mockRepository = mock(UserRepositoryPort.class);
    NotificationPort mockNotification = mock(NotificationPort.class);
    UserService userService = new UserService(mockRepository, mockNotification);
    
    // When
    User user = userService.registerNewUser("test@email.com", "password123", "John Doe");
    
    // Then
    assertThat(user.getEmail()).isEqualTo("test@email.com");
    assertThat(user.getName()).isEqualTo("John Doe");
    verify(mockRepository).save(any(User.class));
    verify(mockNotification).sendWelcomeEmail(any(User.class));
}
```

### 7. **Gestión de Errores Consistente**
```java
// Excepciones del dominio
public class DomainException extends RuntimeException {
    public DomainException(String message) {
        super(message);
    }
}

public class InsufficientFundsException extends DomainException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}

// Uso en el dominio
public class BankAccount {
    private Money balance;
    
    public void withdraw(Money amount) {
        if (balance.isLessThan(amount)) {
            throw new InsufficientFundsException("Fondos insuficientes");
        }
        this.balance = this.balance.subtract(amount);
    }
}
```

## Conclusión

La Arquitectura Hexagonal es una excelente opción para proyectos que requieren:

- **Escalabilidad** y mantenibilidad a largo plazo
- **Flexibilidad** para cambios tecnológicos
- **Alta testabilidad** de la lógica de negocio
- **Desarrollo en equipo** con separación clara de responsabilidades

Es especialmente beneficiosa en:
- Aplicaciones empresariales complejas
- Microservicios
- Sistemas que evolucionan constantemente
- Proyectos con múltiples interfaces de usuario

Sin embargo, debe evaluarse cuidadosamente para proyectos pequeños o simples donde la complejidad adicional podría no justificarse.

---

**Autor:** MiniMax Agent  
**Fecha:** 2025-12-11